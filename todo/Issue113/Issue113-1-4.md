Great! Since S3 serves **static files**, you can’t rely on `.env` at runtime like you do locally. But there’s a trick to **dynamically set the backend URL** so you don’t have to rebuild every time ngrok changes. Here’s how:

---

## **1. Add a config file in your `public/` folder**

Create a simple JSON file, e.g., `public/config.json`:

```json
{
  "BACKEND_URL": "https://fumiko-unalarmed-sprayfully.ngrok-free.dev"
}
```

> Later, whenever ngrok URL changes, you just edit this JSON and re-upload it to S3—no rebuild needed.

---

## **2. Load it in your frontend at runtime**

Modify your `page.tsx`:

```ts
const [backendUrl, setBackendUrl] = useState("");

useEffect(() => {
  // Load config.json dynamically
  const fetchConfig = async () => {
    try {
      const res = await fetch("/config.json");
      const data = await res.json();
      setBackendUrl(data.BACKEND_URL);
    } catch (err) {
      console.error("Failed to load config.json", err);
      setBackendUrl(""); // fallback
    }
  };
  fetchConfig();
}, []);
```

Then replace **all occurrences of** `process.env.NEXT_PUBLIC_BACKEND_URL` with `backendUrl`:

```ts
const res = await fetch(`${backendUrl}/voices`);
...
const res = await fetch(`${backendUrl}/generate-audio`, {...});
```

---

## **3. Deploy / Update**

1. Upload `config.json` along with your frontend files to S3.
2. When ngrok changes, just update the URL inside `config.json` and re-upload that file.
3. No need to rebuild the frontend; the frontend reads the latest URL at runtime.

---

This approach works perfectly for **dynamic testing** with ngrok or even switching between staging/production environments.

If you want, I can also show a **tiny tweak to avoid the “backendUrl is empty initially” problem** so your frontend doesn’t break before `config.json` loads.

Do you want me to show that?
